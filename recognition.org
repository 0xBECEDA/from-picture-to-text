#+STARTUP: showall indent hidestars

* План
** Введение

Цель данного проекта - распознавание текста с картинки без использования
нейросетей вроде сети Tesseract, поскольку точность такого распознавания
недостаточно высока.

Как человек читает текст? Мы не думаем о проблах между словами, строчками
и абзацами, а фокусируемся исключительно на тексте. В нашей программе мы
будем поступать так же. В качестве основной технологии будем использовать
~клеточные автоматы~. Они будут "отсекать" ненужные, фоновые участки
картинки и распознавать шаблоны букв.

Справка: пометки ~TO DO~ означает, что в пункте много неясностей или нет
вообще ничего. Пока пункт не имеет статус ~DONE~, он не считается
завершенным, значит, там есть над чем работать.

А если делать эти пометки в виде [TODO:gmm] то можно еще воспользоваться
M-x what-can-i-do чтобы получить список всех пометок в документе. Это
удобно. "gmm" здесь означает инициалы того, чья тудушка, можно поменять
на свои найдя из в конфиге ~/.emacs.d/init.el

** План действий
*** Получить блоки чистого текста.

Под блоками "чистого текста" понимаются прямоугольники абзацев без пробелов между ними.
Для достижения этого результата мы:

- делим картинку на сегменты единого размера
- в каждом сегменте запускаем по клеточному автомату
- ждем, пока клеточные автоматы пометят все ненужное

[COMMENT:gmm] Я бы не делил картинку на сегменты, а вместо этого
разбросал бы начальные затравочные точки клеточных автоматов равномерно
по картинке (к примеру через каждые 30 пикселей)

[COMMENT:gmm] Я это и имела в виду.

*** TODO Внутреннее устройство клеточного автомата, как автоматы общаются между собой

Для общения объектов программы между собой предлагаю модель передачи
сообщений.

Каждый клеточный автомат представляет собой самостоятельный объект,
который содержит:
- свой уникальный ~id~
- структуру для хранения пикселей
- диспетчер для управления внутренними процедурами

**** Механизм работы клеточного автомата при поиске блоков с фоном

Итак, мы запустили в каждом сегменте по клеточному автомату. Предположим,
что клеточные автоматы начинают анализировать сегменты с середины - так
удобнее для дальнейшей работы (?)

Каждому клеточному автомату присваиваем ~id~ - идентификационный номер -
чтоб можно было отличить один автомат от другого.

***** Механизм работы клеточного автомата в его сегменте.

- Проверяем текущий пиксель.
Нам нужно понять, фоновый фоновой ли это пиксель, и если да, то "свободен"
ли он. Вдруг его уже пометил другой клеточный автомат?

Действуем по следующему алгоритму:
- <?> пиксель цвета фона? (Для начала не факт что мы знаем цвет фона. Будем
  считать, что мы считаем цветом фона пиксели с цветом таким же как цвет
  тех пикселей что нам уже известны. Т.е. если затравка попала в букву - то
  не повезло, т.к. она будет считать цветом фона цвет буквы. Но мы думаем
  что это не очень вероятное событие и можно позволить себе потерять на
  этом часть автоматов)
  - ~Нет!~ - что делать тогда? - думаю искать другой соседний пиксель. Если
    они кончились, то останавливать этот клеточный автомат.
  - ~Да!~:
    - <?> пиксель помечен?
      - ~Нет!~: Помечаем пиксель как принадлежащий текущему клеточному
        автомату:
        - записываем в альфаканал пикселя ~id~ нашедшего его автомата
        - записываем координаты пикселя (куда?). Варианты: список,
          массив, хэш-таблица, бинарное дерево поиска. У каждого автомата
          своя область памяти для записи координат. (лучше сначала
          сделать просто, потом профилировать и только потом
          оптимизировать)
        Проверяем соседние пиксели с 4х сторон: повторить алгоритм, начиная с пункта 1.1.
      - ~Да!~: Мы столкнулись с другим клеточным автоматом.

***** TODO Что делать при столкновении с другим клеточным автоматом.

Наши автоматы работают не только в пределах своих сегментов. Нам нужно,
чтоб они выходили за пределы своих изначальных зон и "сливались" друг с
другом, пока не кончится все непомеченное фоновое пространство на
картинке.

Как мы понимаем, что столкнулись с зоной другого автомата?
Мы нашли фоновый пиксель, который уже кем-то помечен. У нас есть
несколько проблем:

1. Нам нужно, чтоб "сливающиеся" зоны, обработанные клеточными
   автоматами, были прямоугольными или квадратными, поскольку мы хотим
   сохранить фоновое пространство между строками абзаца и буквами.
   Отсюда вытекает проблема 2.

2. Как клеточные автоматы поделят между собой пиксели, чтоб в итоге у нас
   получился именно прямоугольник?
   Надо перебрать все варианты и выбрать наилучший.


   (кстати, а клеточным автоматам, которые будут искать шаблоны
   букв, не пофиг ли на пространство между строчками и словами? Они же
   анализируют только сами буквы. И если это действительно неважно, то
   зачем нам отсекать фон? Можно сразу искать буквы и анализировать их)

   Мы ищем пустые пространства чтобы облегчить работу клеточных
   автоматов, которые будут искать буквы.

~Вариант решения проблемы №2~.

1. Определиться со структурой, в которую мы будем писать координаты
   пикселей, пока будем их "метить". Из адекватных вариантов хэш-таблица
   и бинарное дерево поиска, они быстрее итерации по списку или массиву.
   Построение бинарного дерева:
   - определить, какая координата будет "ведущей", поскольку у нас есть
     значение координат ~x~ и ~y~, т.е. что мы будем
     сравнивать, чтоб понять, в какую ветку дерева писать новый узел.
     Например, у нас есть координаты 3;5 6;8 2;9. Если ориентируемся по
     координате икс, то 3;5 будет корнем, 6;8 - правой веткой, 2;9 -
     левой. Если по игреку, то 3;5 и 6;8 останутся на тех же местах в
     дереве, а вот 2;9 станет новым листом правой ветки.
  - в ситуации когда "ведущая" координата меняться не будет,
    например, координаты будут выглядеть как 3;3 3;4 3;5 3;6 и т.д. Как
    понять, куда писать новые листы? В этом случае можно: сравнить
    дополнительно вторую координату у текущего узла и нового
    листа. Т.е. если координата ~x~ ведущая, и они одинаковые у текущего
    узла и будущего узла, мы сравним их ~y~-координаты, чтоб правильно
    выбрать ветку.
2. создать заголовок у бинарного дерева, куда будет помещен ~id~
   клеточного автомата, которому принадлежит это дерево.
   Таким образом при слиянии зон нам не придется переписывать альфаканалы
   пикселей, чтоб указать остальным, что их "хозяин" изменился.

***** TODO Алгоритм слияния зон при описанном выше решении проблемы №2~

У нас есть 2 клеточных автомата. Доя удобства назовем их "синий" и
"красный". Красный автомат натыкается на фоновый пиксель, который помечен
как "принадлежащий синему". В этом случае красный автомат должен:

1. Послать сообщение хозяину текущего пикселя сообщение о слиянии.
2. Получить ответ, который содержит в себе ~id~ из заголовка нашего
   дерева с пикселями.

Зачем нам этот ~id~ из заголовка, если мы его еще из альфаканала пикселя прочитали?
Да, у нас в альфаканале найденных пикселей написан ~id~ синего
автомата. Но мы помним, что при слиянии мы только поменяем заголовок у
дерева с координатами пикселей, вместо того, чтоб переписать значение
~id~ в альфаканае каждого пикселя. То есть то, что мы вот сейчас в
альфаканале чужих помеченных пикселей прочитали ~id~ синего автомата,
вообще не значит, что пиксели все еще принадлежат ему. Вдруг они уже
перехвачены каким-нибудь "зеленым" автоматом? Поэтому чтоб окончатльено
понять, чьи это пиксели, мы должны получить ~id~ из заголовка их дерева.

Это наталкивает на 2 мысли:
а) даже если у текущего автомата пикселей больше не осталось и
разрастаться ему некуда, умереть он не может: он должен отвечать на
сообщения о слиянии и выдавать ~id~ текущего держателя дерева пикселей
б) не очень эффективный механизм получается: сначала надо обратиться к
одному автомату, потом к другому. А если слияний было уже штук десять, то
нам вообще всю цепочку от первого хозяина до последнего проходить?

Вариант решения: при каждом новом слиянии зон новый хозяин посылает прежним хозяевам
пикселей свой ~id~. Но тогда нужно как-то хранить, какие пиксели кому
принадлежали, что тоже геморройно и не очень эффективно.

3. Каким-то образом найти пограничные пиксели у новой предполагаемой зоны
   и сформировать из нее прямоугольник.

Пограничные пиксели  - это те пиксели, которые находятся на границе с
чужими зонами или текстом. Надо определить, отдать ли все пиксели новому
хозяину или часть оставить себе.

4. Каким-то образом объединить свое дерево с деревом синего автомата.
- Если отдаем все пиксели целиком:
Вариант 1:
Все узлы красного дерева встраиваются в синее дерево, т.е. мы сливаем
деревья. Если после этого не удалить красное дерево как самостоятельный
объект, то при последующих слияниях кол-во требуемой памяти будет расти
экспоненциально. Поскольку все деревья всех автоматов и их слияния будут
копироваться снова и снова. Значит, после слияния, дерево, которое
присоединяют (в нашем случае оно красное), надо бы удалить.
Но при этом надо куда-то записать ~id~ нового собственника дерева
пикселей.
Еще варианты?
- Если отдаем часть пикселей:
  Нужно удалить слитые узлы из красного дерева, чтоб память не засорять и
  включить новые узлы в синее дерево.
Записать ~id~ нового хозяина части пиксеелй?...
При поледующих слияниях будет дикий гемор.

***** TODO Что делать при столкноверии с текстом

Возникающие проблемы:
1. Фон может быть разного цвета. В вк он голубой и белый,
   например. Т.е. тот факт, что цвет пикселя отличается от текущего
   фонового, еще не означает, что мы встретили текст.
2. Текст тоже может быть разного цвета.
3. Если мы все-таки как-то определили, что встретились с текстом, то это
   означает, что фоновое пространство рядом с текстом уже помечено,
   сожрано клеточными автоматами. Оно нам вроде было зачем-то
   нужно(?). Как это предотвратить?
4. Работа автомата не должна прекращаться, как только мы встретились с
   текстом. Например, текст может быть сверху, а снизу его нет. Значит,
   надо как-то обозначить, что наверху нам больше искать нечего, будем
   искать по оставшимся 3 сторонам.

*** TODO Запустить распознавание букв

Думаю стоит продумать теперь распознавание букв, а потом начать писать
имено с рапознавания букв. И только столкнувшись с проблемами
производительности перед распознаванием букв вставим распознавание
пустого пространства, чтобы была возможность оценить насколько это
улучшило скорость работы

Следуя выше изложенной идее, можно было бы распознавать буквы следующим
образом:
1. Вручную берем "пипеткой" из гимпа цвет у текста, сохраняем его как цвет
   текста на этом сайте.
2. Запускаем множество клеточных автоматов на странице. Пусть ищут только
   то, что будет цвета текста.
3. Встретив пиксели цвета буквы, клеточный автомат должен заполнить
   букву, т.е. "размножиться на ее пикселях" и вернуть нам ее шаблон.
4. Получив множество шаблонов, мы вручную укажем, что такой-то шаблон
   соответствует такой-то букве.
5. Запускаем автоматы еще раз, только теперь автоматы будут не просто
   искать шаблоны, но и сразу распознавать их и записывать соответсвующие
   символы в файл?

Таким образом, мы не заморачиваемся с отсеканием фона, а
сосредотачиваемся только на тексте.

Проблемы при это сценарии:
1. Выделив каждому клеточному автомату определыннй участок на картинке,
   мы можем легко столкнуться с проблемой, что буква находится на границе
   2х автоматов. Что делаем тогда?
2. Поиск букв по цвету, т.е. в худшем случае проверка всех пикселей на
   экране - это уйма ресурсов.
3. В каком виде клеточны автомат будет возвращать нам шаблон? Это будет
   картинка буквы, список координат пикселей...?
4. Как мы вообще определяем понятие "шаблон" для компьютера? Человек
   распознает буквы по их внешнему виду, но клеточный автомат не "видит",
   он может только собрать нам координаты пикселей у конкретной буквы,
   например. То есть нам надо каким-то образом явно указать, что если
   координаты пикселей расположены каким-то особым образом, то мы
   воспринимаем это как такой-то шаблон. То есть компьютер должен
   каким-то образом отделять один шаблон от другого.
5. В какой структуре мы будем хранить шаблоны?
6. Каков сценарий, если после настройки всей системы, клеточные автоматы
   нашли на последующих страницах символы, соответствий для которых нет?

Сценарий №2~
1. Сначала отсекаем все лишнее: фон, картинки на странице и т.д.
2. Получаем прямоугольники чистого текста.
Затем действуем согласно первому сценарию.
Все проблемы при этом сохраняются.

(Нельзя сказать, описать букву "А" как "двигайся вверх под углом, затем
под таким же углом спустись вниз, и где-то поставь поперечную палочку",
потому что мы можем "войти" в букву в любой точке.
- Вообще-то можно, но это уже другой способ распознавания (кстати,
  отличная идея). А все шаблоны квадратные, поэтому мы можем выделить буквы)

**** Попытка найти букву клеточным автоматом на картинке

Пробуем найти букву на изображении с помощью клеточного автомата.
Для начала загрузим все функции в слим из файла snapshot.org, который
лежит тут:
https://github.com/0xBECEDA/from-picture-to-text/blob/master/snapshot.org

Демоверсия призвана проверить, работает ли разработанный клеточный
автомат. Его цель:
1. найти букву
2. закрасить ее новым цветом
3. затем сохраняем картинку.

Чтоб нашему клеточному автомату было попроще, возьмем сначала пипеткой в
гимпе цвет шрифта на цветном избражении.

Поиск буквы:
Циклом проходимся по всей картинке.
Как только встречаем цвет буквы, сразу вызываем клеточный автомат,
который ищет "соседей" этого пикселя с таким же цветом. Поиск соседей
заканчивается тогда, когда мы проверили наличие соседей у всех пикселей и
ничего не нашли.
После этого цикл включается на том месте, где остановился.

Правила для клеточного автомата:
. получаем первый пиксель
. проверяем его соседей: сверху, снизу, слева, справа. Если цвет соседа
соответсвует цвету буквы, то заносим координаты в очередь
. берем координаты пикселя из очереди, сразу меняем его цвет,
анализируем его соседей и заносим их координаты в очередь
. работа программы прекращается, когда очередь координат пикселей
оказывается пуста.

#+BEGIN_SRC lisp
  (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
  (defparameter *new-image-path* "~/r/prj/picture->text/result.png")
  (defparameter *test-image* (load-png *test-image-path*))
  (defparameter *queue-of-pixels* (make-queue))
  (defparameter *max-x* (- (array-dimension *test-image* 0) 1))
  (defparameter *max-y* (- (array-dimension *test-image* 1) 1))

  (defparameter *r* 224)
  (defparameter *g* 134)
  (defparameter *b* 26)

  (defparameter *new-r* 255)
  (defparameter *new-g* 0)
  (defparameter *new-b* 0)


  (defun needed-pix? (x y r g b image)
    (if (or (< *max-x* x)
            (< *max-y* y)
            (< x 0)
            (< y 0))
        nil
        (progn
          (format t "x ~A y ~A ~%" x y)
          (format t "r ~A g ~A b ~A ~%" (aref image y x 0)
                  (aref image y x 1) (aref image y x 2))
          (if (and (or (= r (aref image y x 0))
                       ( <= (abs (- r (aref image y x 0))) 35))
                   (or (= g (aref image y x 1))
                       ( <= (abs (- g (aref image y x 1))) 35))
                   (or (= b (aref image y x 2))
                       ( <= (abs (- b (aref image y x 2))) 35)))
              (progn
              (put-pix (make-pix x y))
              ;;(format t "car ~A ~%" *queue-of-pixels*)
              )
              'not))))

  (defun automat (pixels-queue image)
    (if (null (car pixels-queue))
        'done
        (let* ((cur-pix (get-pix pixels-queue))
               (cur-x (get-x cur-pix))
               (cur-y (get-y cur-pix)))
          ;; меняем цвет пикселя
          (format t "~A ~%" (length pixels-queue))
          (setf (aref image cur-y cur-x 0) *new-r*
                (aref image cur-y cur-x 1) *new-g*
                (aref image cur-y cur-x 2) *new-b*)
          ;; проверяем соседей с 4х сторон
          (needed-pix? (+ cur-x 1) cur-y *r* *g* *b* image)
          (needed-pix? (- cur-x 1) cur-y *r* *g* *b* image)
          (needed-pix? cur-x  (+ cur-y 1) *r* *g* *b* image)
          (needed-pix? cur-x  (- cur-y 1) *r* *g* *b* image)
          (automat pixels-queue image))))

  (defun test ()
    (put-pix (make-pix 55 57))
    (automat *queue-of-pixels* *test-image*)
    (destructuring-bind (height width colors)
        (array-dimensions *test-image*)
      (save-png width height *new-image-path* *test-image*)))

  (test)
  ;; ;; TEST: saving screenshot data
  ;; (let* ((to "~/r/prj/picture->text/aaa.png")
  ;;        (image-data (x-snapshot)))
  ;;   (destructuring-bind (height width depth)
  ;;       (array-dimensions image-data)
  ;;     (save-png width height to image-data)))

  ;; (defun find-letter (image)
  ;;   <тут будет цикл>
  ;;   )
#+END_SRC

Конструктор и селекторы для создания и управления очередью пикселей.

#+BEGIN_SRC lisp
  (defun make-queue () (cons nil nil))

  (defun enqueue (obj q)
    (if (null (car q))
        (setf (cdr q) (setf (car q) (list obj)))
        (setf (cdr (cdr q)) (list obj)
              (cdr q) (cdr (cdr q))))
    (car q))

  (defun dequeue (q)
    (pop (car q)))

  (defun make-pix (x y)
    (cons x y))

  (defun put-pix (pix)
    (enqueue pix *queue-of-pixels*))

  (defun get-x (pix)
    (car pix))

  (defun get-y (pix)
    (cdr pix))

  (defun get-pix (queue)
    (dequeue queue))

  (defun empty-queue? (queue)
    (and (null (car queue))
         (null (cdr queue))))

  ;; (defparameter test (make-pix 1 2))
  ;; (defparameter test2 (make-pix 3 4))

  ;; (put-pix test)
  ;; (get-pix *queue-of-pixels*)

  ;; (dequeue *queue-of-pixels*)

#+END_SRC
