#+STARTUP: showall indent hidestars

* План
** Введение

Цель данного проекта - распознавание текста с картинки без использования
нейросетей вроде сети Tesseract, поскольку точность такого распознавания
недостаточно высока.

Как человек читает текст? Мы не думаем о проблах между словами, строчками
и абзацами, а фокусируемся исключительно на тексте. В нашей программе мы
будем поступать так же. В качестве основной технологии будем использовать
~клеточные автоматы~. Они будут "отсекать" ненужные, фоновые участки
картинки и распознавать шаблоны букв.

Справка: пометки ~TO DO~ означает, что в пункте много неясностей или нет
вообще ничего. Пока пункт не имеет статус ~DONE~, он не считается
завершенным, значит, там есть над чем работать.

А если делать эти пометки в виде [TODO:gmm] то можно еще воспользоваться
M-x what-can-i-do чтобы получить список всех пометок в документе. Это
удобно. "gmm" здесь означает инициалы того, чья тудушка, можно поменять
на свои найдя из в конфиге ~/.emacs.d/init.el

** План действий
*** Получить блоки чистого текста.

Под блоками "чистого текста" понимаются прямоугольники абзацев без пробелов между ними.
Для достижения этого результата мы:

- делим картинку на сегменты единого размера
- в каждом сегменте запускаем по клеточному автомату
- ждем, пока клеточные автоматы пометят все ненужное

[COMMENT:gmm] Я бы не делил картинку на сегменты, а вместо этого
разбросал бы начальные затравочные точки клеточных автоматов равномерно
по картинке (к примеру через каждые 30 пикселей)

[COMMENT:gmm] Я это и имела в виду.

*** TODO Внутреннее устройство клеточного автомата, как автоматы общаются между собой

Для общения объектов программы между собой предлагаю модель передачи
сообщений.

Каждый клеточный автомат представляет собой самостоятельный объект,
который содержит:
- свой уникальный ~id~
- структуру для хранения пикселей
- диспетчер для управления внутренними процедурами

**** Механизм работы клеточного автомата при поиске блоков с фоном

Итак, мы запустили в каждом сегменте по клеточному автомату. Предположим,
что клеточные автоматы начинают анализировать сегменты с середины - так
удобнее для дальнейшей работы (?)

Каждому клеточному автомату присваиваем ~id~ - идентификационный номер -
чтоб можно было отличить один автомат от другого.

***** Механизм работы клеточного автомата в его сегменте.

- Проверяем текущий пиксель.
Нам нужно понять, фоновый фоновой ли это пиксель, и если да, то "свободен"
ли он. Вдруг его уже пометил другой клеточный автомат?

Действуем по следующему алгоритму:
- <?> пиксель цвета фона? (Для начала не факт что мы знаем цвет фона. Будем
  считать, что мы считаем цветом фона пиксели с цветом таким же как цвет
  тех пикселей что нам уже известны. Т.е. если затравка попала в букву - то
  не повезло, т.к. она будет считать цветом фона цвет буквы. Но мы думаем
  что это не очень вероятное событие и можно позволить себе потерять на
  этом часть автоматов)
  - ~Нет!~ - что делать тогда? - думаю искать другой соседний пиксель. Если
    они кончились, то останавливать этот клеточный автомат.
  - ~Да!~:
    - <?> пиксель помечен?
      - ~Нет!~: Помечаем пиксель как принадлежащий текущему клеточному
        автомату:
        - записываем в альфаканал пикселя ~id~ нашедшего его автомата
        - записываем координаты пикселя (куда?). Варианты: список,
          массив, хэш-таблица, бинарное дерево поиска. У каждого автомата
          своя область памяти для записи координат. (лучше сначала
          сделать просто, потом профилировать и только потом
          оптимизировать)
        Проверяем соседние пиксели с 4х сторон: повторить алгоритм, начиная с пункта 1.1.
      - ~Да!~: Мы столкнулись с другим клеточным автоматом.

***** TODO Что делать при столкновении с другим клеточным автоматом.

Наши автоматы работают не только в пределах своих сегментов. Нам нужно,
чтоб они выходили за пределы своих изначальных зон и "сливались" друг с
другом, пока не кончится все непомеченное фоновое пространство на
картинке.

Как мы понимаем, что столкнулись с зоной другого автомата?
Мы нашли фоновый пиксель, который уже кем-то помечен. У нас есть
несколько проблем:

1. Нам нужно, чтоб "сливающиеся" зоны, обработанные клеточными
   автоматами, были прямоугольными или квадратными, поскольку мы хотим
   сохранить фоновое пространство между строками абзаца и буквами.
   Отсюда вытекает проблема 2.

2. Как клеточные автоматы поделят между собой пиксели, чтоб в итоге у нас
   получился именно прямоугольник?
   Надо перебрать все варианты и выбрать наилучший.


   (кстати, а клеточным автоматам, которые будут искать шаблоны
   букв, не пофиг ли на пространство между строчками и словами? Они же
   анализируют только сами буквы. И если это действительно неважно, то
   зачем нам отсекать фон? Можно сразу искать буквы и анализировать их)

   Мы ищем пустые пространства чтобы облегчить работу клеточных
   автоматов, которые будут искать буквы.

~Вариант решения проблемы №2~.

1. Определиться со структурой, в которую мы будем писать координаты
   пикселей, пока будем их "метить". Из адекватных вариантов хэш-таблица
   и бинарное дерево поиска, они быстрее итерации по списку или массиву.
   Построение бинарного дерева:
   - определить, какая координата будет "ведущей", поскольку у нас есть
     значение координат ~x~ и ~y~, т.е. что мы будем
     сравнивать, чтоб понять, в какую ветку дерева писать новый узел.
     Например, у нас есть координаты 3;5 6;8 2;9. Если ориентируемся по
     координате икс, то 3;5 будет корнем, 6;8 - правой веткой, 2;9 -
     левой. Если по игреку, то 3;5 и 6;8 останутся на тех же местах в
     дереве, а вот 2;9 станет новым листом правой ветки.
  - в ситуации когда "ведущая" координата меняться не будет,
    например, координаты будут выглядеть как 3;3 3;4 3;5 3;6 и т.д. Как
    понять, куда писать новые листы? В этом случае можно: сравнить
    дополнительно вторую координату у текущего узла и нового
    листа. Т.е. если координата ~x~ ведущая, и они одинаковые у текущего
    узла и будущего узла, мы сравним их ~y~-координаты, чтоб правильно
    выбрать ветку.
2. создать заголовок у бинарного дерева, куда будет помещен ~id~
   клеточного автомата, которому принадлежит это дерево.
   Таким образом при слиянии зон нам не придется переписывать альфаканалы
   пикселей, чтоб указать остальным, что их "хозяин" изменился.

***** TODO Алгоритм слияния зон при описанном выше решении проблемы №2~

У нас есть 2 клеточных автомата. Доя удобства назовем их "синий" и
"красный". Красный автомат натыкается на фоновый пиксель, который помечен
как "принадлежащий синему". В этом случае красный автомат должен:

1. Послать сообщение хозяину текущего пикселя сообщение о слиянии.
2. Получить ответ, который содержит в себе ~id~ из заголовка нашего
   дерева с пикселями.

Зачем нам этот ~id~ из заголовка, если мы его еще из альфаканала пикселя прочитали?
Да, у нас в альфаканале найденных пикселей написан ~id~ синего
автомата. Но мы помним, что при слиянии мы только поменяем заголовок у
дерева с координатами пикселей, вместо того, чтоб переписать значение
~id~ в альфаканае каждого пикселя. То есть то, что мы вот сейчас в
альфаканале чужих помеченных пикселей прочитали ~id~ синего автомата,
вообще не значит, что пиксели все еще принадлежат ему. Вдруг они уже
перехвачены каким-нибудь "зеленым" автоматом? Поэтому чтоб окончатльено
понять, чьи это пиксели, мы должны получить ~id~ из заголовка их дерева.

Это наталкивает на 2 мысли:
а) даже если у текущего автомата пикселей больше не осталось и
разрастаться ему некуда, умереть он не может: он должен отвечать на
сообщения о слиянии и выдавать ~id~ текущего держателя дерева пикселей
б) не очень эффективный механизм получается: сначала надо обратиться к
одному автомату, потом к другому. А если слияний было уже штук десять, то
нам вообще всю цепочку от первого хозяина до последнего проходить?

Вариант решения: при каждом новом слиянии зон новый хозяин посылает прежним хозяевам
пикселей свой ~id~. Но тогда нужно как-то хранить, какие пиксели кому
принадлежали, что тоже геморройно и не очень эффективно.

3. Каким-то образом найти пограничные пиксели у новой предполагаемой зоны
   и сформировать из нее прямоугольник.

Пограничные пиксели  - это те пиксели, которые находятся на границе с
чужими зонами или текстом. Надо определить, отдать ли все пиксели новому
хозяину или часть оставить себе.

4. Каким-то образом объединить свое дерево с деревом синего автомата.
- Если отдаем все пиксели целиком:
Вариант 1:
Все узлы красного дерева встраиваются в синее дерево, т.е. мы сливаем
деревья. Если после этого не удалить красное дерево как самостоятельный
объект, то при последующих слияниях кол-во требуемой памяти будет расти
экспоненциально. Поскольку все деревья всех автоматов и их слияния будут
копироваться снова и снова. Значит, после слияния, дерево, которое
присоединяют (в нашем случае оно красное), надо бы удалить.
Но при этом надо куда-то записать ~id~ нового собственника дерева
пикселей.
Еще варианты?
- Если отдаем часть пикселей:
  Нужно удалить слитые узлы из красного дерева, чтоб память не засорять и
  включить новые узлы в синее дерево.
Записать ~id~ нового хозяина части пиксеелй?...
При поледующих слияниях будет дикий гемор.

***** TODO Что делать при столкноверии с текстом

Возникающие проблемы:
1. Фон может быть разного цвета. В вк он голубой и белый,
   например. Т.е. тот факт, что цвет пикселя отличается от текущего
   фонового, еще не означает, что мы встретили текст.
2. Текст тоже может быть разного цвета.
3. Если мы все-таки как-то определили, что встретились с текстом, то это
   означает, что фоновое пространство рядом с текстом уже помечено,
   сожрано клеточными автоматами. Оно нам вроде было зачем-то
   нужно(?). Как это предотвратить?
4. Работа автомата не должна прекращаться, как только мы встретились с
   текстом. Например, текст может быть сверху, а снизу его нет. Значит,
   надо как-то обозначить, что наверху нам больше искать нечего, будем
   искать по оставшимся 3 сторонам.

*** TODO Запустить распознавание букв

Думаю стоит продумать теперь распознавание букв, а потом начать писать
имено с рапознавания букв. И только столкнувшись с проблемами
производительности перед распознаванием букв вставим распознавание
пустого пространства, чтобы была возможность оценить насколько это
улучшило скорость работы

Следуя выше изложенной идее, можно было бы распознавать буквы следующим
образом:
1. Вручную берем "пипеткой" из гимпа цвет у текста, сохраняем его как цвет
   текста на этом сайте.
2. Запускаем множество клеточных автоматов на странице. Пусть ищут только
   то, что будет цвета текста.
3. Встретив пиксели цвета буквы, клеточный автомат должен заполнить
   букву, т.е. "размножиться на ее пикселях" и вернуть нам ее шаблон.
4. Получив множество шаблонов, мы вручную укажем, что такой-то шаблон
   соответствует такой-то букве.
5. Запускаем автоматы еще раз, только теперь автоматы будут не просто
   искать шаблоны, но и сразу распознавать их и записывать соответсвующие
   символы в файл?

Таким образом, мы не заморачиваемся с отсеканием фона, а
сосредотачиваемся только на тексте.

Проблемы при это сценарии:
1. Выделив каждому клеточному автомату определыннй участок на картинке,
   мы можем легко столкнуться с проблемой, что буква находится на границе
   2х автоматов. Что делаем тогда?
2. Поиск букв по цвету, т.е. в худшем случае проверка всех пикселей на
   экране - это уйма ресурсов.
3. В каком виде клеточны автомат будет возвращать нам шаблон? Это будет
   картинка буквы, список координат пикселей...?
4. Как мы вообще определяем понятие "шаблон" для компьютера? Человек
   распознает буквы по их внешнему виду, но клеточный автомат не "видит",
   он может только собрать нам координаты пикселей у конкретной буквы,
   например. То есть нам надо каким-то образом явно указать, что если
   координаты пикселей расположены каким-то особым образом, то мы
   воспринимаем это как такой-то шаблон. То есть компьютер должен
   каким-то образом отделять один шаблон от другого.
5. В какой структуре мы будем хранить шаблоны?
6. Каков сценарий, если после настройки всей системы, клеточные автоматы
   нашли на последующих страницах символы, соответствий для которых нет?

Сценарий №2~
1. Сначала отсекаем все лишнее: фон, картинки на странице и т.д.
2. Получаем прямоугольники чистого текста.
Затем действуем согласно первому сценарию.
Все проблемы при этом сохраняются.

(Нельзя сказать, описать букву "А" как "двигайся вверх под углом, затем
под таким же углом спустись вниз, и где-то поставь поперечную палочку",
потому что мы можем "войти" в букву в любой точке.
- Вообще-то можно, но это уже другой способ распознавания (кстати,
  отличная идея). А все шаблоны квадратные, поэтому мы можем выделить буквы)

**** Попытка найти букву клеточным автоматом на картинке

Пробуем найти букву на изображении с помощью клеточного автомата.
Для начала загрузим все функции в слим из файла snapshot.org, который
лежит тут:
https://github.com/0xBECEDA/from-picture-to-text/blob/master/snapshot.org

Демоверсия призвана проверить, работает ли разработанный клеточный
автомат. Его цель:
1. найти букву
2. закрасить ее новым цветом
3. затем сохраняем картинку.

Чтоб нашему клеточному автомату было попроще, возьмем сначала пипеткой в
гимпе цвет шрифта на цветном избражении.

Поиск буквы:
Циклом проходимся по всей картинке.
Как только встречаем цвет буквы, сразу вызываем клеточный автомат,
который ищет "соседей" этого пикселя с таким же цветом. Поиск соседей
заканчивается тогда, когда мы проверили наличие соседей у всех пикселей и
ничего не нашли.
После этого цикл включается на том месте, где остановился.

#+NAME: defs
#+BEGIN_SRC lisp :noweb yes
<<queue>>

(defparameter *queue-of-pixels* (make-queue))
(defparameter *max-x* (- (array-dimension *test-image* 0) 1))
(defparameter *max-y* (- (array-dimension *test-image* 1) 1))

(defparameter *r* 224)
(defparameter *g* 134)
(defparameter *b* 26)

(defparameter *color-tolerance* 100)

(defparameter *new-r* 255)
(defparameter *new-g* 0)
(defparameter *new-b* 0)

<<needed-pix?>>

#+END_SRC

Конструктор и селекторы для создания и управления очередью пикселей и
самими пикселями.

#+NAME: queue
#+BEGIN_SRC lisp :noweb yes
  (defun make-queue () (cons nil nil))

  (defun enqueue (obj q)
    (if (null (car q))
        (setf (cdr q) (setf (car q) (list obj)))
        (setf (cdr (cdr q)) (list obj)
              (cdr q) (cdr (cdr q))))
    (car q))

  (defun dequeue (q)
    (pop (car q)))

  (defun make-pix (x y)
    (cons x y))

  (defun put-pix (pix)
    (enqueue pix *queue-of-pixels*))

  (defun get-x (pix)
    (car pix))

  (defun get-y (pix)
    (cdr pix))

  (defun get-pix (queue)
    (dequeue queue))

  (defun empty-queue? (queue)
    (and (null (car queue))
         (null (cdr queue))))

  ;; (defparameter test (make-pix 1 2))
  ;; (defparameter test2 (make-pix 3 4))

  ;; (put-pix test)
  ;; (get-pix *queue-of-pixels*)

  ;; (dequeue *queue-of-pixels*)

#+END_SRC

Функция проверки цвета конкретного пикселя.
Пока что заточена только под полноцветное изображение, т.е. сравнивается
RGB текущего пикселя и заданный RGB буквы. Если цвет пикселя нам
подходит, его координаты отправляются в очередь для дальнейшей
обработки.

#+NAME: needed-pix?
#+BEGIN_SRC lisp :noweb yes
  (defun needed-pix? (x y r g b image)
    (if (or (< *max-x* x)
            (< *max-y* y)
            (< x 0)
            (< y 0))
        nil
        (progn
          ;; (format t "x ~A y ~A ~%" x y)
          ;; (format t "r ~A g ~A b ~A ~%" (aref image y x 0)
          ;;        (aref image y x 1) (aref image y x 2))
          (if (and (or (= r (aref image y x 0))
                       ( <= (abs (- r (aref image y x 0))) *color-tolerance*))
                   (or (= g (aref image y x 1))
                       ( <= (abs (- g (aref image y x 1))) *color-tolerance*))
                   (or (= b (aref image y x 2))
                       ( <= (abs (- b (aref image y x 2))) *color-tolerance*)))
              (progn
                (put-pix (make-pix x y))
                t
                ;;(format t "car ~A ~%" *queue-of-pixels*)
                )
              nil))))
#+END_SRC

Правила для клеточного автомата:
- получаем первый пиксель из очереди
- закрашиваем его
- проверяем его соседей: сверху, снизу, слева, справа.
- берем следующий пиксель из очереди

Работа функции прекращается, когда очередь координат пикселей
оказывается пуста. Это означает, что обработка текущего символа закончилась.

К этому механизму добавилась важная деталь: мы будем сохранять крайние
точки найденной буквы, что упростит нам работу с ней. Для этого мы будем
пользоваться специальными структурами, их массивом и функцией ~check-sides~, об
устройстве которых будет сказано ниже. По окончанию работы мы просто
вернем готовую структуру.

#+NAME: automat
#+BEGIN_SRC lisp :noweb yes
    (defun automat (pixels-queue cur-struct image)
    (if (null (car pixels-queue))
        (progn
          ;;(format t " automat: done struct ~A ~%" cur-struct)
          cur-struct
          )
        (let* ((cur-pix (get-pix pixels-queue))
               (cur-x (get-x cur-pix))
               (cur-y (get-y cur-pix)))
          ;;(format t " automat: struct ~A ~%" cur-struct)
          ;;(format t " automat: cur-pix ~A ~%" cur-pix)
          (setf cur-struct (check-sides cur-pix cur-struct))
          ;; меняем цвет пикселя
          ;;(format t "~A ~%" (length pixels-queue))
          (setf (aref image cur-y cur-x 0) *new-r*
                (aref image cur-y cur-x 1) *new-g*
                (aref image cur-y cur-x 2) *new-b*)
          ;; проверяем соседей с 4х сторон
          (needed-pix? (+ cur-x 1) cur-y *r* *g* *b* image)
          (needed-pix? (- cur-x 1) cur-y *r* *g* *b* image)
          (needed-pix? cur-x  (+ cur-y 1) *r* *g* *b* image)
          (needed-pix? cur-x  (- cur-y 1) *r* *g* *b* image)
          (automat pixels-queue cur-struct image))))
#+END_SRC

Цикл, который проходится по всей картинке ряд за рядом в поисках точки
вхождения в символ. Если точка найдена, то мы вызываем ~automat~,
передаем ему пустую структуру для дальнейшей работы с символом.
После окончания работы ~automat~ мы кладем структуру в массив и
продолжаем поиск с того места, где остановились.

#+NAME: find-letter
#+BEGIN_SRC lisp :noweb yes
(defun find-letter (image)
  (do ((x 0 (incf x)))
      ((= x *max-x*))
    (do ((y 0 (incf y)))
        ((= y *max-y*))
      (if (needed-pix? x y *r* *g* *b* image)
          (let ((cur-struct (aref *array-of-letters* *array-of-letters-indx*)))
            (setf (aref *array-of-letters* *array-of-letters-indx*)
                  (automat *queue-of-pixels* cur-struct *test-image*))
            (incf *array-of-letters-indx*))))))

<<crop_pattern>>
#+END_SRC

**** Создание шаблонов.

Немного усовершенствуем идею клеточного автомата. Раньше он просто
закрашивал буквы, теперь его задача - сохранить крайние точки букв. Так
мы сможем правильно высчитать размер буквы и без проблем вырезать ее из
общей картинки, получив таким образом наш шаблон.
К тому же, сохранение координат позволяет нам избавиться от минимум 2х
проблем:
- Чтоб сравнить шаблоны с буквами, не нужно будет заново
  проходить по картинке. Просто будем брать структуру с координатами и
накладывать шаблон прямо на это место на картинке
- Оптимизация скорости распознавания буквы и шаблона.
Буквы бывают разного размера. Зная крайние точки буквы, можно посчитать
высоту и ширину буквы. А значит, мы не будем пытаться наложить шаблон "m"
на букву "i", поскольку у них принципиально разные размеры.

Как сохранить крайние координаты букв?
- создаем структуру для каждой буквы
- создаем массив для хранения этих структур
- при анализе пикселей будем сверять их координаты с уже имеющимися в
  структуре, если структура как-то заполнена, конечно
  по окончанию работы над буквой, мы должны получить заполненную полностью
  структуру буквы и положить ее в массив.

#+NAME: array_of_letters
#+BEGIN_SRC lisp :noweb yes
  (defstruct letter
    up down left right)

  (defconstant *array-of-letters* (make-array *array-of-letters-amount*))
#+END_SRC

Массив будем сразу заполнять пустыми структурами, а затем просто
заполнять их поля. Так же заведем индекс заполнения массива, чтоб не
приходилось каждый раз проходить по массиву в поиске незаполненной
структуры, и переменную, отображающую размер массива. Таким образом не
придется вручную менять размер массива во всех тестах программы.

#+NAME: fill_array
#+BEGIN_SRC lisp :noweb yes
(dotimes (i *array-of-letters-amount*)
    (setf (aref *array-of-letters* i) (make-letter)))
#+END_SRC

#+NAME: array_of_letters_index
#+BEGIN_SRC lisp :noweb yes
  (defparameter *array-of-letters-indx* 0)

 (defconstant *array-of-letters-amount* 500)
#+END_SRC

Можно было бы использовать пулл, но пришлось бы все равно писать в пулл
как в обычный массив, потому что если использовать ~vector-pop~ и
~vector-push~, то мы будем при каждом вызове ~automat~ использовать одну
и ту же структуру. Чтобы этого не делать, пришлось бы сначала ждать, пока
мы проанализируем вообще все символы и только потом класть их в пулл. К
тому же, всегда можно забыть, как нетипично  мы используем пулл, и
получить сложно отслеживаемые ошибки.

Подробнее о сравнении координат пикселя и координат крайних точек буквы.
У нас может возникнуть 2 сценария:
1. Мы встречем пустой слот.
Если это так, то просто запишем туда координаты пикселя. При последующем
анализе буквы, слот скорее всего будет переписан. Но нам очень важно,
чтоб все 4 слота структуры были заполнены какими-то координатами, иначе
размеры буквы посчитать будет невозможно.

2. В остальных случаях мы действуем по следующему сценарию:
Мы последоватльено сравниваем ~x~ координату текущего пикселя с ~x~
координатами полей ~left~ и ~reight~, а ~y~ координату сравниваем с ~y~
координатой полей ~up~ ~down~.
Зачем мы это делаем? Дело в том, что один и тот же пиксель может
оказаться и самым верхним, и самым правым, например. Соотвтетсвенно, он
должен попасть и в поле ~up~, и в поле ~right~. В противном случае
структура не будет отражать реальных размеров буквы.
Обрати внимание, что для проверки условий используется
~progn~,объединяющий ифы в единое выражение, а не ~cond~, поскольку
~cond~ прекратил бы проверять условия, как только одно из них сработало
бы. А нам нужно, чтоб проверились все.
Для удобства ~check-sides~ будет возвращать измененную структуру.

#+NAME: check_sides
#+BEGIN_SRC lisp :noweb yes
  <<array_of_letters>>

  (defun check-sides (pix struct)
    (progn
      (if (or (null (letter-up struct))
              (< (get-y pix) (get-y (letter-up struct))))
          (setf (letter-up struct) pix))
      (if (or (null (letter-down struct))
              (> (get-y pix) (get-y (letter-down struct))))
          (setf (letter-down struct) pix))
      (if (or (null (letter-left struct))
              (< (get-x pix) (get-x (letter-left struct))))
          (setf (letter-left struct) pix))
      (if (or (null (letter-right struct))
              (> (get-x pix) (get-x (letter-right struct))))
          (progn
            (setf (letter-right struct) pix)
            struct)
          struct)))

  <<automat>>

  ;; ТЕСТ на заполнение пустой структуры с последующим переписыванием слотов
  ;; (let ((cur-struct (aref *array-of-letters* 1)))
  ;;   (check-sides (make-pix 90 90) cur-struct)
  ;;   (format t "~A ~% "cur-struct)
  ;;   (check-sides (make-pix 30 40) cur-struct)
  ;;   (format t "~A ~% "cur-struct)
  ;;   (check-sides (make-pix 12 0) cur-struct)
  ;;   (format t "~A ~% "cur-struct)
  ;;   (check-sides (make-pix 14 32) cur-struct)
  ;;   (format t "~A ~% "cur-struct)
  ;;   (check-sides (make-pix 14 100) cur-struct)
  ;;   (format t "~A ~% "cur-struct)
  ;;   )

#+END_SRC

**** Вырезание шаблонов.
Теперь, когда мы пjлучили координатs каждой буквы - а буквой мы считаем
все, что не фон, - мы можем написать функцию, которая будет вырезать
шаблон из каринки и сохранять его в папку.

Для вырезания шаблона мы будем копировать нужные пиксели в отдельный
массив и сохранять его. Поскольку у нас координаты букв записаны без
всякого "запаса", то чтоб вырезать букву правильно, не обрубив ее
последние пиксели, мы прибавим пару пикселей к границам, если это
возможно. Мы же не хотим  вылететь за границы массива.

Ширина буквы рассчитывается как разница между ккординатами ~x~ левого и
правого края, а высота - как разница между ~y~ координатами верхнего и
нижнего края.

~crop-pattern~ универсален, поскольку принимает структуру пикселя и
массив пикселей изображения, из которого мы вырезаем шаблон. Единственное
ограничение: структура должна быть типа ~letter~, а массив должен
содержать пиксели изображения.

#+NAME: crop_pattern
#+BEGIN_SRC lisp :noweb yes
  (defun crop-pattern (pix-struct image)
    (let* ((up (letter-up pix-struct))
           (down (letter-down pix-struct))
           (right (letter-right pix-struct))
           (left (letter-left pix-struct))
           (y-start (if (or (= (get-y up) 0) (= (get-y up) 1))
                        (get-y up)
                        (- (get-y up) 2)))
           (x-start (if (or (= (get-x left) 0) (= (get-x left) 1))
                        (get-x left)
                        (- (get-x left) 2)))
           (y-end (if (or (= (get-y down) *max-y*) (= (get-y down) (- *max-y* 1)))
                      (get-y down)
                      (+ (get-y down) 2)))
           (x-end (if (or (= (get-x right) *max-x*) (= (get-x right) (- *max-x* 1)))
                      (get-x right)
                      (+ (get-x right) 2)))
           (height-pattern (- y-end y-start))
           (width-pattern (- x-end x-start))
           (colors-pattern 4)
           (pattern-dims (list height-pattern width-pattern colors-pattern))
           (pattern-image (make-array pattern-dims :element-type '(unsigned-byte 8))))
      (format t "pattern dims ~A ~%" pattern-dims)
      (format t "struct ~A ~%" pix-struct)
      (do ((image-y y-start (incf image-y))
           (pattern-y 0 (incf pattern-y)))
          ((= image-y y-end))
        (do ((image-x x-start (incf image-x))
             (pattern-x 0 (incf pattern-x)))
            ((= image-x x-end))
          (do ((z 0 (incf z)))
              ((= z colors-pattern))
            ;; (format t "mx ~A my ~A  px ~A py ~A ~%" image-x image-y
            ;;         pattern-x pattern-y)
            ;; (format t "mx ~A my ~A  px ~A py ~A ~%" image-x image-y
            ;;         pattern-x pattern-y)
            (setf (aref pattern-image pattern-y pattern-x z)
                  (aref image image-y image-x z)))))
      pattern-image))

  ;; TECT для проверки crop-pattern отдельно от системы
  (defun test-crop-alone ()
    (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
    (defparameter *test-image* (load-png *test-image-path*))
    (defparameter *pattern-image-path* "~/r/prj/picture->text/pattern.png")
    (let ((struct (make-letter)))
      (setf (letter-up struct) (make-pix 90 0)
            (letter-down struct) (make-pix 90 50)
            (letter-left struct) (make-pix 100 0)
            (letter-right struct) (make-pix 150 80))
      ;;(defparameter pattern (crop-pattern struct *test-image*))))
       ;; (aref pattern 49 53 0)
      (let ((pattern (crop-pattern struct *test-image*)))
        (destructuring-bind (height  width  &optional colors)
            (array-dimensions pattern)
          (format t "pattern dims ~A ~A ~A ~%" height  width colors)
          (save-png width height *pattern-image-path* pattern)))))

  ;; (test-crop-alone)

  ;;ТЕСТ crop со всей системой без цикла
  (defun test-crop-with-system ()
    (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
    (defparameter *pattern-image-path* "~/r/prj/picture->text/pattern.png")
    (defparameter *test-image* (load-png *test-image-path*))
    <<array_of_letters_index>>
    <<fill_array>>
    (find-letter *test-image*)
    (let ((pattern (crop-pattern (aref *array-of-letters* 0) *test-image*)))
      (destructuring-bind (height  width  &optional colors)
          (array-dimensions pattern)
        (save-png width height *pattern-image-path* pattern))))

  ;; (test-crop-with-system)

  ;; ТЕСТ crop-pattern со всей системой: задача вырезать все шаблоны по координатам в массиве
  (defun test-crop-with-system-in-cycle ()
    (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
    (defparameter *test-image* (load-png *test-image-path*))
    (defparameter *array-of-letters-indx* 0)
    (dotimes (i *array-of-letters-amount*)
      (setf (aref *array-of-letters* i) (make-letter)))
    (find-letter *test-image*)
    (do ((i 0 (incf i)))
        ((= i *array-of-letters-amount*) 'done)
      (let* ((cur-struct (aref *array-of-letters* i))
             (pattern (if (letter-up cur-struct)
                          (crop-pattern cur-struct *test-image*)
                          nil)))
        (if pattern
            (destructuring-bind (height width  &optional colors)
                (array-dimensions pattern)
              (save-png width height (format nil
                                             "/home/ss/r/prj/picture->text/patterns/pattern~A.png"
                                             i)
                        pattern))
            (return-from test-crop-with-system-in-cycle 'done)))))
  ;; (test-crop-with-system-in-cycle)
#+END_SRC

**** Запуск

На данный вид существует 2 варианта запуска: с циклом и без. Без цикла
удобно запускать, когда нужно протестить систему и отследить правильность
всех значений. Можно "натравить" автомат на конкретную букву,
предварительно узнав ее координаты в гимпе, и сравнить ожидаемую модель
поведения с реальностью.

#+NAME: tests
#+BEGIN_SRC lisp :noweb yes

  ;; (defun test ()
  ;;   (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
  ;;   (defparameter *test-image* (load-png *test-image-path*))
  ;;   <<array_of_letters_index>>
  ;;   <<fill_array>>
  ;;   (put-pix (make-pix 207 40))
  ;;   (let ((cur-struct (aref *array-of-letters* 0)))
  ;;     (setf (aref *array-of-letters* *array-of-letters-indx*)
  ;;           (automat *queue-of-pixels* cur-struct *test-image*))
  ;;   (destructuring-bind (height width colors)
  ;;       (array-dimensions *test-image*)
  ;;     (save-png width height *new-image-path* *test-image*))))

  (defun test ()
    (defparameter *test-image-path* "~/r/prj/picture->text/aaa.png")
    (defparameter *test-image* (load-png *test-image-path*))
    <<array_of_letters_index>>
    <<fill_array>>
    (find-letter *test-image*)
    (destructuring-bind (height width colors)
        (array-dimensions *test-image*)
      (save-png width height *new-image-path* *test-image*)))

  (test)

#+END_SRC

**** Сборка

#+NAME: recognition
#+BEGIN_SRC lisp :tangle code-file.lisp :noweb yes tangle :exports code :padline no :comments none
<<defs>>
<<check_sides>>
<<find-letter>>
<<tests>>
#+END_SRC
